/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@webreflection/group-nodes@0.1.12/src/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const { defineProperties: e, getOwnPropertyDescriptor: t, setPrototypeOf: r } = Object, n = Symbol.for("group-nodes"), s = n in globalThis, o = NodeList.prototype, l = DocumentFragment.prototype, a = Node.prototype, i = e => r(e, o), { appendChild: c, compareDocumentPosition: p, contains: u, insertBefore: d, removeChild: h, replaceChild: g } = a, { append: m, moveBefore: f, prepend: v, replaceChildren: C } = l, y = new WeakMap, N = new Map, b = document.createComment(""), S = t(a, "nextSibling").get, B = ({ start: e, end: t }) => { const r = []; for (; (e = S.call(e)) !== t;)r.push(e); return r }, E = (e, t = y.get(e)) => (w(t) ? C.call(e, t.start, ...B(t), t.end) : (v.call(e, t.start), m.call(e, t.end)), e), w = ({ start: e, end: t }) => { const { parentNode: r } = e, n = null != r; return (r !== t.parentNode || n && 4 !== p.call(e, t)) && W(), n }, x = (e, t = y.get(e)) => { const r = B(t); return t.start.remove(), C.apply(e, r), t.end.remove(), e }, W = () => { throw new Error("Invalid GroupNodes boundary") }, D = e => y.get(e).start, P = (e, t) => { const { parentNode: r } = t; d.call(r, b, t); for (const t of e) d.call(r, t, b); h.call(r, b) }; class T { constructor(e, t) { this.start = e, this.end = t } } const $ = ({ nodeType: e }) => 1 === e, R = ({ start: e, end: t }) => e.nextSibling !== t, k = ({ start: { parentNode: e } }, t, ...r) => e[t](...r), A = ({ data: e, nodeType: t }, r) => { 8 === t && e === r || W() }, O = e => e instanceof F, q = e => O(e) ? E(e) : e, I = (e, t = !1) => { for (let r = 0; r < e.length; r++)O(e[r]) ? e[r] = E(e[r]) : t && (e[r] = document.createTextNode(e[r])); return e }, j = e => O(e) ? D(e) : e, G = new WeakMap; let M = null; class F extends DocumentFragment { #e = ""; static from(e, t) { const r = e.data.slice(1, -1); r || W(), A(e, `<${r}>`), A(t, `</${r}>`); const n = G.get(e)?.deref(), s = G.get(t)?.deref(); if (n !== s && W(), n) return n; const o = new T(e, t); w(o), M = o; try { return new this(r) } finally { M = null } } constructor(e = "") { super().#e = e; const t = M || new T(document.createComment(`<${e}>`), document.createComment(`</${e}>`)); y.set(this, t); const r = new WeakRef(this); G.set(t.start, r), G.set(t.end, r), e && !N.has(e) && N.set(e, r) } get [Symbol.toStringTag]() { return `GroupNodes<${this.#e}>` } get childElementCount() { const e = y.get(this); return w(e) ? B(e).filter($).length : super.childElementCount } get childNodes() { const e = y.get(this); return w(e) ? i(B(e)) : super.childNodes } get children() { const e = y.get(this); return w(e) ? i(B(e).filter($)) : super.children } get firstChild() { const e = y.get(this); if (w(e)) { const t = e.start.nextSibling; return t === e.end ? null : t } return super.firstChild } get firstElementChild() { const e = y.get(this); return w(e) ? B(e).find($) || null : super.firstElementChild } get isConnected() { return y.get(this).start.isConnected } get lastChild() { const e = y.get(this); if (w(e)) { const t = e.end.previousSibling; return t === e.start ? null : t } return super.lastChild } get lastElementChild() { const e = y.get(this); return w(e) ? B(e).findLast($) || null : super.lastElementChild } get nextSibling() { const e = y.get(this); return w(e) ? e.end.nextSibling : super.nextSibling } get parentElement() { const e = y.get(this); return w(e) ? e.start.parentElement : super.parentElement } get parentNode() { const e = y.get(this); return w(e) ? e.start.parentNode : super.parentNode } get previousSibling() { const e = y.get(this); return w(e) ? e.start.previousSibling : super.previousSibling } get nodeName() { return "#group-nodes" } get name() { return this.#e } appendChild(e) { const t = y.get(this); return w(t) ? k(t, "insertBefore", e, t.end) : super.appendChild(e) } cloneNode(e = !1) { const t = new this.constructor(this.#e); for (const r of this.childNodes) c.call(t, r.cloneNode(e)); return t } compareDocumentPosition(e) { const t = y.get(this); return w(t) ? k(t, "compareDocumentPosition", e) : super.compareDocumentPosition(j(e)) } contains(e) { const t = y.get(this); return w(t) ? k(t, "contains", e) : super.contains(j(e)) } getRootNode(...e) { const t = y.get(this); return w(t) ? t.start.getRootNode(...e) : super.getRootNode(...e) } hasChildNodes() { const e = y.get(this); return w(e) ? R(e) : super.hasChildNodes() } insertBefore(e, t) { const r = y.get(this); return w(r) ? k(r, "insertBefore", e, t) : super.insertBefore(q(e), j(t)) } removeChild(e) { const t = y.get(this); return w(t) ? k(t, "removeChild", e) : O(e) ? x(e) : super.removeChild(e) } replaceChild(e, t) { const r = y.get(this); return w(r) ? k(r, "replaceChild", e, t) : (O(t) && (d.call(this, b, D(t)), x(t), t = b), g.call(this, q(e), t)) } append(...e) { const t = y.get(this); w(t) ? P(I(e, !0), t.end) : super.append(...e) } getElementById(e) { const t = y.get(this); return w(t) ? k(t, "getElementById", e) : super.getElementById(e) } moveBefore(e, t) { const r = y.get(this); return w(r) ? k(r, "moveBefore", e, t) : super.moveBefore(e, t) } prepend(...e) { const t = y.get(this); w(t) ? P(I(e, !0), t.start.nextSibling) : super.prepend(...e) } querySelector(e) { const t = y.get(this); return w(t) ? B(t).find((t => t.matches?.(e))) || null : super.querySelector(e) } querySelectorAll(e) { const t = y.get(this); return w(t) ? B(t).filter((t => t.matches?.(e))) : super.querySelector(e) } replaceChildren(...e) { const t = y.get(this); if (w(t)) { for (let t = 0; t < e.length; t++)O(e[t]) && (e[t] = E(e[t])); if (C.apply(this, e), R(t)) { const e = document.createRange(); e.setStartAfter(t.start), e.setEndBefore(t.end), e.deleteContents() } e.length && d.call(t.end.parentNode, this, t.end) } else super.replaceChildren(...e) } after(...e) { const t = y.get(this); w(t) && t.end.after(...e) } before(...e) { const t = y.get(this); w(t) && t.start.before(...e) } remove() { this.parentNode?.removeChild(this) } replaceWith(...e) { const t = y.get(this), { parentNode: r } = t.start; r && (d.call(r, b, t.start), x(this, t), b.replaceWith(...e)) } } const L = s ? globalThis[n] : globalThis[n] = F; if (s || e(l, { append: { value(...e) { m.apply(this, I(e)) } }, moveBefore: { value(e, t) { return f.call(this, q(e), j(t)) } }, prepend: { value(...e) { v.apply(this, I(e)) } }, replaceChildren: { value(...e) { C.apply(this, I(e)) } } }), !s) { const t = CharacterData.prototype, { after: r, before: n, replaceWith: s } = t; e(t, { after: { value(...e) { r.apply(this, I(e)) } }, before: { value(...e) { n.apply(this, I(e)) } }, replaceWith: { value(...e) { s.apply(this, I(e)) } } }) } const z = Element.prototype, { after: H, append: J, before: K, insertAdjacentElement: Q, prepend: U, replaceChildren: V, replaceWith: X, moveBefore: Y } = z; s || e(z, { after: { value(...e) { H.apply(this, I(e)) } }, append: { value(...e) { J.apply(this, I(e)) } }, before: { value(...e) { K.apply(this, I(e)) } }, insertAdjacentElement: { value(e, t) { return Q.call(this, e, q(t)) } }, moveBefore: { value(e, t) { return Y.call(this, q(e), j(t)) } }, prepend: { value(...e) { U.apply(this, I(e)) } }, replaceChildren: { value(...e) { V.apply(this, I(e)) } }, replaceWith: { value(...e) { X.apply(this, I(e)) } } }), s || e(a, { appendChild: { value(e) { return c.call(this, q(e)) } }, compareDocumentPosition: { value(e) { return p.call(this, j(e)) } }, contains: { value(e) { return u.call(this, j(e)) } }, insertBefore: { value(e, t) { return d.call(this, q(e), j(t)) } }, removeChild: { value(e) { return O(e) ? x(e) : h.call(this, e) } }, replaceChild: { value(e, t) { return O(t) && (d.call(this, b, D(t)), x(t), t = b), g.call(this, q(e), t) } } }), s || e(Range.prototype, { groupNodes: { configurable: !0, enumerable: !0, writable: !0, value() { const { commonAncestorContainer: e, startOffset: t, endOffset: r } = this, { childNodes: n } = e; return L.from(n[t], n[r - 1]) } } }), s || e(document, { groups: { configurable: !0, enumerable: !0, value: new Proxy(N, { has(e, t) { return e.has(t) || !!this.get(e, t) }, get(e, t) { let r = e.get(t)?.deref() || null; if (t = String(t), !r && t) { const e = document.createTreeWalker(document.body, 128), n = `<${t}>`, s = `</${t}>`; let o, l, a, i; for (; i = e.nextNode();)if (l) { if (i.data === s && i.parentNode === o) { a = i; break } } else i.data === n && (l = i, o = l.parentNode); l && (a ? r = L.from(l, a) : W()) } return r } }) } }); export { L as NodeGroup }; export default null
//# sourceMappingURL=/sm/98c743553eb57e85c5ea2ffe67118bda67b625d624894b89e420166aebd6e2b9.map
